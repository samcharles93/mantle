--- a/internal/tensor/gemm.go
+++ b/internal/tensor/gemm.go
@@ -1,199 +1,236 @@
 package tensor
 
 import "runtime"
 
 // Tuned for the benchmark shape (256^3) and typical L1/L2 sizes.
 // tileN is kept moderate to reduce register pressure in the inner loop.
 const (
 	tileM = 64
 	tileN = 64
 	tileK = 32
 )
+
+// unrollJ is the inner-loop unroll factor over N.
+// 8 is a good tradeoff for Go's bounds-check elimination and register pressure.
+const unrollJ = 8
 
 type gemmTask struct {
 	C, A, B     *Mat
 	alpha, beta float32
 	rs, re      int
 	done        chan struct{}
 }
@@ -92,6 +129,10 @@
 func GemmPar(C, A, B *Mat, alpha, beta float32, workers int) {
 	if A.C != B.R || C.R != A.R || C.C != B.C {
 		panic("gemm: dimension mismatch")
 	}
+	// Fast return for empty work.
+	if C.R == 0 || C.C == 0 || A.C == 0 {
+		return
+	}
-	if C.R == 0 || C.C == 0 {
-		return
-	}
 
 	if workers <= 0 {
 		workers = runtime.GOMAXPROCS(0)
 	}
@@ -151,6 +192,7 @@
 func gemmRangeRows(C, A, B *Mat, alpha, beta float32, rs, re int) {
 	// Fast path: common inference case alpha=1, beta=0.
 	if alpha == 1 && beta == 0 {
 		gemmRangeRowsAlpha1Beta0(C, A, B, rs, re)
 		return
 	}
@@ -193,7 +235,7 @@
 	for i0 := rs; i0 < re; i0 += tileM {
 		iMax := min(i0+tileM, re)
 		for k0 := 0; k0 < k; k0 += tileK {
 			kMax := min(k0+tileK, k)
 			for j0 := 0; j0 < n; j0 += tileN {
 				jMax := min(j0+tileN, n)
-				blockUpdateGeneric(C.Data, A.Data, B.Data, cStride, aStride, bStride, alpha, i0, iMax, j0, jMax, k0, kMax)
+				blockUpdateGeneric(C.Data, A.Data, B.Data, cStride, aStride, bStride, alpha, i0, iMax, j0, jMax, k0, kMax)
 			}
 		}
 	}
 }
@@ -230,7 +272,7 @@
 	for i0 := rs; i0 < re; i0 += tileM {
 		iMax := min(i0+tileM, re)
 		for k0 := 0; k0 < k; k0 += tileK {
 			kMax := min(k0+tileK, k)
 			for j0 := 0; j0 < n; j0 += tileN {
 				jMax := min(j0+tileN, n)
-				blockUpdateAlpha1(cData, aData, bData, cStride, aStride, bStride, i0, iMax, j0, jMax, k0, kMax)
+				blockUpdateAlpha1(cData, aData, bData, cStride, aStride, bStride, i0, iMax, j0, jMax, k0, kMax)
 			}
 		}
 	}
 }
 
 func blockUpdateGeneric(cData, aData, bData []float32, cStride, aStride, bStride int, alpha float32, i0, iMax, j0, jMax, k0, kMax int) {
-	width := jMax - j0
-	for i := i0; i < iMax; i++ {
-		aRow := aData[i*aStride:]
-		cOff := i*cStride + j0
-		cRow := cData[cOff : cOff+width]
-
-		for kk := k0; kk < kMax; kk++ {
-			aik := aRow[kk] * alpha
-			bOff := kk*bStride + j0
-			bRow := bData[bOff : bOff+width]
-
-			j := 0
-			for ; j+7 < width; j += 8 {
-				cRow[j+0] += aik * bRow[j+0]
-				cRow[j+1] += aik * bRow[j+1]
-				cRow[j+2] += aik * bRow[j+2]
-				cRow[j+3] += aik * bRow[j+3]
-				cRow[j+4] += aik * bRow[j+4]
-				cRow[j+5] += aik * bRow[j+5]
-				cRow[j+6] += aik * bRow[j+6]
-				cRow[j+7] += aik * bRow[j+7]
-			}
-			for ; j < width; j++ {
-				cRow[j] += aik * bRow[j]
-			}
-		}
-	}
+	width := jMax - j0
+	if width <= 0 {
+		return
+	}
+	for i := i0; i < iMax; i++ {
+		aRow := aData[i*aStride:]
+		cOff := i*cStride + j0
+		cRow := cData[cOff : cOff+width]
+
+		// Split into an unrolled prefix and a scalar tail.
+		wU := width &^ (unrollJ - 1)
+		for kk := k0; kk < kMax; kk++ {
+			aik := aRow[kk] * alpha
+			bOff := kk*bStride + j0
+			bRow := bData[bOff : bOff+width]
+
+			// Help BCE by keeping indices provably in range.
+			for j := 0; j < wU; j += unrollJ {
+				cRow[j+0] += aik * bRow[j+0]
+				cRow[j+1] += aik * bRow[j+1]
+				cRow[j+2] += aik * bRow[j+2]
+				cRow[j+3] += aik * bRow[j+3]
+				cRow[j+4] += aik * bRow[j+4]
+				cRow[j+5] += aik * bRow[j+5]
+				cRow[j+6] += aik * bRow[j+6]
+				cRow[j+7] += aik * bRow[j+7]
+			}
+			for j := wU; j < width; j++ {
+				cRow[j] += aik * bRow[j]
+			}
+		}
+	}
 }
 
 func blockUpdateAlpha1(cData, aData, bData []float32, cStride, aStride, bStride int, i0, iMax, j0, jMax, k0, kMax int) {
-	width := jMax - j0
-	for i := i0; i < iMax; i++ {
-		aRow := aData[i*aStride:]
-		cOff := i*cStride + j0
-		cRow := cData[cOff : cOff+width]
-
-		for kk := k0; kk < kMax; kk++ {
-			aik := aRow[kk]
-			bOff := kk*bStride + j0
-			bRow := bData[bOff : bOff+width]
-
-			j := 0
-			for ; j+7 < width; j += 8 {
-				cRow[j+0] += aik * bRow[j+0]
-				cRow[j+1] += aik * bRow[j+1]
-				cRow[j+2] += aik * bRow[j+2]
-				cRow[j+3] += aik * bRow[j+3]
-				cRow[j+4] += aik * bRow[j+4]
-				cRow[j+5] += aik * bRow[j+5]
-				cRow[j+6] += aik * bRow[j+6]
-				cRow[j+7] += aik * bRow[j+7]
-			}
-			for ; j < width; j++ {
-				cRow[j] += aik * bRow[j]
-			}
-		}
-	}
+	width := jMax - j0
+	if width <= 0 {
+		return
+	}
+	for i := i0; i < iMax; i++ {
+		aRow := aData[i*aStride:]
+		cOff := i*cStride + j0
+		cRow := cData[cOff : cOff+width]
+
+		wU := width &^ (unrollJ - 1)
+		for kk := k0; kk < kMax; kk++ {
+			aik := aRow[kk]
+			bOff := kk*bStride + j0
+			bRow := bData[bOff : bOff+width]
+
+			for j := 0; j < wU; j += unrollJ {
+				cRow[j+0] += aik * bRow[j+0]
+				cRow[j+1] += aik * bRow[j+1]
+				cRow[j+2] += aik * bRow[j+2]
+				cRow[j+3] += aik * bRow[j+3]
+				cRow[j+4] += aik * bRow[j+4]
+				cRow[j+5] += aik * bRow[j+5]
+				cRow[j+6] += aik * bRow[j+6]
+				cRow[j+7] += aik * bRow[j+7]
+			}
+			for j := wU; j < width; j++ {
+				cRow[j] += aik * bRow[j]
+			}
+		}
+	}
 }