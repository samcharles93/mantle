{
  "diff": "--- a/internal/tensor/gemm.go\n+++ b/internal/tensor/gemm.go\n@@ -1,214 +1,250 @@\n package tensor\n \n import \"runtime\"\n@@\n func gemmRangeRows(C, A, B *Mat, alpha, beta float32, rs, re int) {\n \t// Fast path: common inference case alpha=1, beta=0.\n \tif alpha == 1 \u0026\u0026 beta == 0 {\n \t\tgemmRangeRowsAlpha1Beta0(C, A, B, rs, re)\n \t\treturn\n \t}\n@@\n-\t// m := A.R\n-\t// _ = m\n-\tn := B.C\n-\tk := A.C\n-\n-\taStride := A.Stride\n-\tbStride := B.Stride\n-\tcStride := C.Stride\n-\n-\t// Blocked loops.\n-\tfor i0 := rs; i0 \u003c re; i0 += tileM {\n-\t\tiMax := min(i0+tileM, re)\n-\t\tfor k0 := 0; k0 \u003c k; k0 += tileK {\n-\t\t\tkMax := min(k0+tileK, k)\n-\t\t\tfor j0 := 0; j0 \u003c n; j0 += tileN {\n-\t\t\t\tjMax := min(j0+tileN, n)\n-\t\t\t\tblockUpdateGeneric(C.Data, A.Data, B.Data, cStride, aStride, bStride, alpha, i0, iMax, j0, jMax, k0, kMax)\n-\t\t\t}\n-\t\t}\n-\t}\n+\tn := B.C\n+\tk := A.C\n+\n+\taStride := A.Stride\n+\tbStride := B.Stride\n+\tcStride := C.Stride\n+\n+\tcData := C.Data\n+\taData := A.Data\n+\tbData := B.Data\n+\n+\t// Blocked loops.\n+\tfor i0 := rs; i0 \u003c re; i0 += tileM {\n+\t\tiMax := min(i0+tileM, re)\n+\t\tfor k0 := 0; k0 \u003c k; k0 += tileK {\n+\t\t\tkMax := min(k0+tileK, k)\n+\t\t\tfor j0 := 0; j0 \u003c n; j0 += tileN {\n+\t\t\t\tjMax := min(j0+tileN, n)\n+\t\t\t\tblockUpdateGeneric(cData, aData, bData, cStride, aStride, bStride, alpha, i0, iMax, j0, jMax, k0, kMax)\n+\t\t\t}\n+\t\t}\n+\t}\n }\n@@\n func gemmRangeRowsAlpha1Beta0(C, A, B *Mat, rs, re int) {\n \t// beta==0: clear C range once, then accumulate.\n \tcStride := C.Stride\n \tn := C.C\n \tcData := C.Data\n@@\n \t// Blocked loops.\n \tfor i0 := rs; i0 \u003c re; i0 += tileM {\n \t\tiMax := min(i0+tileM, re)\n \t\tfor k0 := 0; k0 \u003c k; k0 += tileK {\n \t\t\tkMax := min(k0+tileK, k)\n \t\t\tfor j0 := 0; j0 \u003c n; j0 += tileN {\n \t\t\t\tjMax := min(j0+tileN, n)\n-\t\t\t\tblockUpdateAlpha1(cData, aData, bData, cStride, aStride, bStride, i0, iMax, j0, jMax, k0, kMax)\n+\t\t\t\tblockUpdateAlpha1(cData, aData, bData, cStride, aStride, bStride, i0, iMax, j0, jMax, k0, kMax)\n \t\t\t}\n \t\t}\n \t}\n }\n \n func blockUpdateGeneric(cData, aData, bData []float32, cStride, aStride, bStride int, alpha float32, i0, iMax, j0, jMax, k0, kMax int) {\n-\twidth := jMax - j0\n-\tfor i := i0; i \u003c iMax; i++ {\n-\t\taRow := aData[i*aStride:]\n-\t\tcOff := i*cStride + j0\n-\t\tcRow := cData[cOff : cOff+width]\n-\n-\t\tfor kk := k0; kk \u003c kMax; kk++ {\n-\t\t\taik := aRow[kk] * alpha\n-\t\t\tbOff := kk*bStride + j0\n-\t\t\tbRow := bData[bOff : bOff+width]\n-\n-\t\t\tj := 0\n-\t\t\tfor ; j+7 \u003c width; j += 8 {\n-\t\t\t\tcRow[j+0] += aik * bRow[j+0]\n-\t\t\t\tcRow[j+1] += aik * bRow[j+1]\n-\t\t\t\tcRow[j+2] += aik * bRow[j+2]\n-\t\t\t\tcRow[j+3] += aik * bRow[j+3]\n-\t\t\t\tcRow[j+4] += aik * bRow[j+4]\n-\t\t\t\tcRow[j+5] += aik * bRow[j+5]\n-\t\t\t\tcRow[j+6] += aik * bRow[j+6]\n-\t\t\t\tcRow[j+7] += aik * bRow[j+7]\n-\t\t\t}\n-\t\t\tfor ; j \u003c width; j++ {\n-\t\t\t\tcRow[j] += aik * bRow[j]\n-\t\t\t}\n-\t\t}\n-\t}\n+\twidth := jMax - j0\n+\tfor i := i0; i \u003c iMax; i++ {\n+\t\taRow := aData[i*aStride:]\n+\t\tcOff := i*cStride + j0\n+\t\tcRow := cData[cOff : cOff+width]\n+\n+\t\tfor kk := k0; kk \u003c kMax; kk++ {\n+\t\t\taik := aRow[kk] * alpha\n+\t\t\tbOff := kk*bStride + j0\n+\t\t\tbRow := bData[bOff : bOff+width]\n+\n+\t\t\t// Unroll by 16 for the common tile width (64) to reduce loop overhead.\n+\t\t\tj := 0\n+\t\t\tfor ; j+15 \u003c width; j += 16 {\n+\t\t\t\tcRow[j+0] += aik * bRow[j+0]\n+\t\t\t\tcRow[j+1] += aik * bRow[j+1]\n+\t\t\t\tcRow[j+2] += aik * bRow[j+2]\n+\t\t\t\tcRow[j+3] += aik * bRow[j+3]\n+\t\t\t\tcRow[j+4] += aik * bRow[j+4]\n+\t\t\t\tcRow[j+5] += aik * bRow[j+5]\n+\t\t\t\tcRow[j+6] += aik * bRow[j+6]\n+\t\t\t\tcRow[j+7] += aik * bRow[j+7]\n+\t\t\t\tcRow[j+8] += aik * bRow[j+8]\n+\t\t\t\tcRow[j+9] += aik * bRow[j+9]\n+\t\t\t\tcRow[j+10] += aik * bRow[j+10]\n+\t\t\t\tcRow[j+11] += aik * bRow[j+11]\n+\t\t\t\tcRow[j+12] += aik * bRow[j+12]\n+\t\t\t\tcRow[j+13] += aik * bRow[j+13]\n+\t\t\t\tcRow[j+14] += aik * bRow[j+14]\n+\t\t\t\tcRow[j+15] += aik * bRow[j+15]\n+\t\t\t}\n+\t\t\tfor ; j+7 \u003c width; j += 8 {\n+\t\t\t\tcRow[j+0] += aik * bRow[j+0]\n+\t\t\t\tcRow[j+1] += aik * bRow[j+1]\n+\t\t\t\tcRow[j+2] += aik * bRow[j+2]\n+\t\t\t\tcRow[j+3] += aik * bRow[j+3]\n+\t\t\t\tcRow[j+4] += aik * bRow[j+4]\n+\t\t\t\tcRow[j+5] += aik * bRow[j+5]\n+\t\t\t\tcRow[j+6] += aik * bRow[j+6]\n+\t\t\t\tcRow[j+7] += aik * bRow[j+7]\n+\t\t\t}\n+\t\t\tfor ; j \u003c width; j++ {\n+\t\t\t\tcRow[j] += aik * bRow[j]\n+\t\t\t}\n+\t\t}\n+\t}\n }\n \n func blockUpdateAlpha1(cData, aData, bData []float32, cStride, aStride, bStride int, i0, iMax, j0, jMax, k0, kMax int) {\n-\twidth := jMax - j0\n-\tfor i := i0; i \u003c iMax; i++ {\n-\t\taRow := aData[i*aStride:]\n-\t\tcOff := i*cStride + j0\n-\t\tcRow := cData[cOff : cOff+width]\n-\n-\t\tfor kk := k0; kk \u003c kMax; kk++ {\n-\t\t\taik := aRow[kk]\n-\t\t\tbOff := kk*bStride + j0\n-\t\t\tbRow := bData[bOff : bOff+width]\n-\n-\t\t\tj := 0\n-\t\t\tfor ; j+7 \u003c width; j += 8 {\n-\t\t\t\tcRow[j+0] += aik * bRow[j+0]\n-\t\t\t\tcRow[j+1] += aik * bRow[j+1]\n-\t\t\t\tcRow[j+2] += aik * bRow[j+2]\n-\t\t\t\tcRow[j+3] += aik * bRow[j+3]\n-\t\t\t\tcRow[j+4] += aik * bRow[j+4]\n-\t\t\t\tcRow[j+5] += aik * bRow[j+5]\n-\t\t\t\tcRow[j+6] += aik * bRow[j+6]\n-\t\t\t\tcRow[j+7] += aik * bRow[j+7]\n-\t\t\t}\n-\t\t\tfor ; j \u003c width; j++ {\n-\t\t\t\tcRow[j] += aik * bRow[j]\n-\t\t\t}\n-\t\t}\n-\t}\n+\twidth := jMax - j0\n+\tfor i := i0; i \u003c iMax; i++ {\n+\t\taRow := aData[i*aStride:]\n+\t\tcOff := i*cStride + j0\n+\t\tcRow := cData[cOff : cOff+width]\n+\n+\t\tfor kk := k0; kk \u003c kMax; kk++ {\n+\t\t\taik := aRow[kk]\n+\t\t\tbOff := kk*bStride + j0\n+\t\t\tbRow := bData[bOff : bOff+width]\n+\n+\t\t\tj := 0\n+\t\t\tfor ; j+15 \u003c width; j += 16 {\n+\t\t\t\tcRow[j+0] += aik * bRow[j+0]\n+\t\t\t\tcRow[j+1] += aik * bRow[j+1]\n+\t\t\t\tcRow[j+2] += aik * bRow[j+2]\n+\t\t\t\tcRow[j+3] += aik * bRow[j+3]\n+\t\t\t\tcRow[j+4] += aik * bRow[j+4]\n+\t\t\t\tcRow[j+5] += aik * bRow[j+5]\n+\t\t\t\tcRow[j+6] += aik * bRow[j+6]\n+\t\t\t\tcRow[j+7] += aik * bRow[j+7]\n+\t\t\t\tcRow[j+8] += aik * bRow[j+8]\n+\t\t\t\tcRow[j+9] += aik * bRow[j+9]\n+\t\t\t\tcRow[j+10] += aik * bRow[j+10]\n+\t\t\t\tcRow[j+11] += aik * bRow[j+11]\n+\t\t\t\tcRow[j+12] += aik * bRow[j+12]\n+\t\t\t\tcRow[j+13] += aik * bRow[j+13]\n+\t\t\t\tcRow[j+14] += aik * bRow[j+14]\n+\t\t\t\tcRow[j+15] += aik * bRow[j+15]\n+\t\t\t}\n+\t\t\tfor ; j+7 \u003c width; j += 8 {\n+\t\t\t\tcRow[j+0] += aik * bRow[j+0]\n+\t\t\t\tcRow[j+1] += aik * bRow[j+1]\n+\t\t\t\tcRow[j+2] += aik * bRow[j+2]\n+\t\t\t\tcRow[j+3] += aik * bRow[j+3]\n+\t\t\t\tcRow[j+4] += aik * bRow[j+4]\n+\t\t\t\tcRow[j+5] += aik * bRow[j+5]\n+\t\t\t\tcRow[j+6] += aik * bRow[j+6]\n+\t\t\t\tcRow[j+7] += aik * bRow[j+7]\n+\t\t\t}\n+\t\t\tfor ; j \u003c width; j++ {\n+\t\t\t\tcRow[j] += aik * bRow[j]\n+\t\t\t}\n+\t\t}\n+\t}\n }",
  "file": "",
  "reasoning_for_change": "Increase inner-loop unrolling (16-wide) and hoist frequently used slices/fields to reduce loop overhead and bounds-check pressure in the hot GEMM micro-kernel, improving throughput for the benchmarkâ€™s 64-wide tiles.",
  "summary_of_changes": "Hoisted matrix data/stride locals in gemmRangeRows and expanded the inner j-loop unrolling in blockUpdateGeneric/blockUpdateAlpha1 from 8 to 16 (with an 8-wide fallback) to cut loop overhead on the common 64-column tile size. No API changes and no additional allocations."
}