{
  "diff": "--- a/internal/tensor/gemm.go\n+++ b/internal/tensor/gemm.go\n@@ -1,199 +1,236 @@\n package tensor\n \n import \"runtime\"\n \n // Tuned for the benchmark shape (256^3) and typical L1/L2 sizes.\n // tileN is kept moderate to reduce register pressure in the inner loop.\n const (\n \ttileM = 64\n \ttileN = 64\n \ttileK = 32\n )\n+\n+// unrollJ is the inner-loop unroll factor over N.\n+// 8 is a good tradeoff for Go's bounds-check elimination and register pressure.\n+const unrollJ = 8\n \n type gemmTask struct {\n \tC, A, B     *Mat\n \talpha, beta float32\n \trs, re      int\n \tdone        chan struct{}\n }\n@@ -92,6 +129,10 @@\n func GemmPar(C, A, B *Mat, alpha, beta float32, workers int) {\n \tif A.C != B.R || C.R != A.R || C.C != B.C {\n \t\tpanic(\"gemm: dimension mismatch\")\n \t}\n+\t// Fast return for empty work.\n+\tif C.R == 0 || C.C == 0 || A.C == 0 {\n+\t\treturn\n+\t}\n-\tif C.R == 0 || C.C == 0 {\n-\t\treturn\n-\t}\n \n \tif workers \u003c= 0 {\n \t\tworkers = runtime.GOMAXPROCS(0)\n \t}\n@@ -151,6 +192,7 @@\n func gemmRangeRows(C, A, B *Mat, alpha, beta float32, rs, re int) {\n \t// Fast path: common inference case alpha=1, beta=0.\n \tif alpha == 1 \u0026\u0026 beta == 0 {\n \t\tgemmRangeRowsAlpha1Beta0(C, A, B, rs, re)\n \t\treturn\n \t}\n@@ -193,7 +235,7 @@\n \tfor i0 := rs; i0 \u003c re; i0 += tileM {\n \t\tiMax := min(i0+tileM, re)\n \t\tfor k0 := 0; k0 \u003c k; k0 += tileK {\n \t\t\tkMax := min(k0+tileK, k)\n \t\t\tfor j0 := 0; j0 \u003c n; j0 += tileN {\n \t\t\t\tjMax := min(j0+tileN, n)\n-\t\t\t\tblockUpdateGeneric(C.Data, A.Data, B.Data, cStride, aStride, bStride, alpha, i0, iMax, j0, jMax, k0, kMax)\n+\t\t\t\tblockUpdateGeneric(C.Data, A.Data, B.Data, cStride, aStride, bStride, alpha, i0, iMax, j0, jMax, k0, kMax)\n \t\t\t}\n \t\t}\n \t}\n }\n@@ -230,7 +272,7 @@\n \tfor i0 := rs; i0 \u003c re; i0 += tileM {\n \t\tiMax := min(i0+tileM, re)\n \t\tfor k0 := 0; k0 \u003c k; k0 += tileK {\n \t\t\tkMax := min(k0+tileK, k)\n \t\t\tfor j0 := 0; j0 \u003c n; j0 += tileN {\n \t\t\t\tjMax := min(j0+tileN, n)\n-\t\t\t\tblockUpdateAlpha1(cData, aData, bData, cStride, aStride, bStride, i0, iMax, j0, jMax, k0, kMax)\n+\t\t\t\tblockUpdateAlpha1(cData, aData, bData, cStride, aStride, bStride, i0, iMax, j0, jMax, k0, kMax)\n \t\t\t}\n \t\t}\n \t}\n }\n \n func blockUpdateGeneric(cData, aData, bData []float32, cStride, aStride, bStride int, alpha float32, i0, iMax, j0, jMax, k0, kMax int) {\n-\twidth := jMax - j0\n-\tfor i := i0; i \u003c iMax; i++ {\n-\t\taRow := aData[i*aStride:]\n-\t\tcOff := i*cStride + j0\n-\t\tcRow := cData[cOff : cOff+width]\n-\n-\t\tfor kk := k0; kk \u003c kMax; kk++ {\n-\t\t\taik := aRow[kk] * alpha\n-\t\t\tbOff := kk*bStride + j0\n-\t\t\tbRow := bData[bOff : bOff+width]\n-\n-\t\t\tj := 0\n-\t\t\tfor ; j+7 \u003c width; j += 8 {\n-\t\t\t\tcRow[j+0] += aik * bRow[j+0]\n-\t\t\t\tcRow[j+1] += aik * bRow[j+1]\n-\t\t\t\tcRow[j+2] += aik * bRow[j+2]\n-\t\t\t\tcRow[j+3] += aik * bRow[j+3]\n-\t\t\t\tcRow[j+4] += aik * bRow[j+4]\n-\t\t\t\tcRow[j+5] += aik * bRow[j+5]\n-\t\t\t\tcRow[j+6] += aik * bRow[j+6]\n-\t\t\t\tcRow[j+7] += aik * bRow[j+7]\n-\t\t\t}\n-\t\t\tfor ; j \u003c width; j++ {\n-\t\t\t\tcRow[j] += aik * bRow[j]\n-\t\t\t}\n-\t\t}\n-\t}\n+\twidth := jMax - j0\n+\tif width \u003c= 0 {\n+\t\treturn\n+\t}\n+\tfor i := i0; i \u003c iMax; i++ {\n+\t\taRow := aData[i*aStride:]\n+\t\tcOff := i*cStride + j0\n+\t\tcRow := cData[cOff : cOff+width]\n+\n+\t\t// Split into an unrolled prefix and a scalar tail.\n+\t\twU := width \u0026^ (unrollJ - 1)\n+\t\tfor kk := k0; kk \u003c kMax; kk++ {\n+\t\t\taik := aRow[kk] * alpha\n+\t\t\tbOff := kk*bStride + j0\n+\t\t\tbRow := bData[bOff : bOff+width]\n+\n+\t\t\t// Help BCE by keeping indices provably in range.\n+\t\t\tfor j := 0; j \u003c wU; j += unrollJ {\n+\t\t\t\tcRow[j+0] += aik * bRow[j+0]\n+\t\t\t\tcRow[j+1] += aik * bRow[j+1]\n+\t\t\t\tcRow[j+2] += aik * bRow[j+2]\n+\t\t\t\tcRow[j+3] += aik * bRow[j+3]\n+\t\t\t\tcRow[j+4] += aik * bRow[j+4]\n+\t\t\t\tcRow[j+5] += aik * bRow[j+5]\n+\t\t\t\tcRow[j+6] += aik * bRow[j+6]\n+\t\t\t\tcRow[j+7] += aik * bRow[j+7]\n+\t\t\t}\n+\t\t\tfor j := wU; j \u003c width; j++ {\n+\t\t\t\tcRow[j] += aik * bRow[j]\n+\t\t\t}\n+\t\t}\n+\t}\n }\n \n func blockUpdateAlpha1(cData, aData, bData []float32, cStride, aStride, bStride int, i0, iMax, j0, jMax, k0, kMax int) {\n-\twidth := jMax - j0\n-\tfor i := i0; i \u003c iMax; i++ {\n-\t\taRow := aData[i*aStride:]\n-\t\tcOff := i*cStride + j0\n-\t\tcRow := cData[cOff : cOff+width]\n-\n-\t\tfor kk := k0; kk \u003c kMax; kk++ {\n-\t\t\taik := aRow[kk]\n-\t\t\tbOff := kk*bStride + j0\n-\t\t\tbRow := bData[bOff : bOff+width]\n-\n-\t\t\tj := 0\n-\t\t\tfor ; j+7 \u003c width; j += 8 {\n-\t\t\t\tcRow[j+0] += aik * bRow[j+0]\n-\t\t\t\tcRow[j+1] += aik * bRow[j+1]\n-\t\t\t\tcRow[j+2] += aik * bRow[j+2]\n-\t\t\t\tcRow[j+3] += aik * bRow[j+3]\n-\t\t\t\tcRow[j+4] += aik * bRow[j+4]\n-\t\t\t\tcRow[j+5] += aik * bRow[j+5]\n-\t\t\t\tcRow[j+6] += aik * bRow[j+6]\n-\t\t\t\tcRow[j+7] += aik * bRow[j+7]\n-\t\t\t}\n-\t\t\tfor ; j \u003c width; j++ {\n-\t\t\t\tcRow[j] += aik * bRow[j]\n-\t\t\t}\n-\t\t}\n-\t}\n+\twidth := jMax - j0\n+\tif width \u003c= 0 {\n+\t\treturn\n+\t}\n+\tfor i := i0; i \u003c iMax; i++ {\n+\t\taRow := aData[i*aStride:]\n+\t\tcOff := i*cStride + j0\n+\t\tcRow := cData[cOff : cOff+width]\n+\n+\t\twU := width \u0026^ (unrollJ - 1)\n+\t\tfor kk := k0; kk \u003c kMax; kk++ {\n+\t\t\taik := aRow[kk]\n+\t\t\tbOff := kk*bStride + j0\n+\t\t\tbRow := bData[bOff : bOff+width]\n+\n+\t\t\tfor j := 0; j \u003c wU; j += unrollJ {\n+\t\t\t\tcRow[j+0] += aik * bRow[j+0]\n+\t\t\t\tcRow[j+1] += aik * bRow[j+1]\n+\t\t\t\tcRow[j+2] += aik * bRow[j+2]\n+\t\t\t\tcRow[j+3] += aik * bRow[j+3]\n+\t\t\t\tcRow[j+4] += aik * bRow[j+4]\n+\t\t\t\tcRow[j+5] += aik * bRow[j+5]\n+\t\t\t\tcRow[j+6] += aik * bRow[j+6]\n+\t\t\t\tcRow[j+7] += aik * bRow[j+7]\n+\t\t\t}\n+\t\t\tfor j := wU; j \u003c width; j++ {\n+\t\t\t\tcRow[j] += aik * bRow[j]\n+\t\t\t}\n+\t\t}\n+\t}\n }",
  "file": "",
  "reasoning_for_change": "Restructuring the inner j-loop into an unrolled prefix plus tail improves bounds-check elimination and reduces loop overhead in the hottest path, speeding up BenchmarkGemmPar without changing results or allocations.",
  "summary_of_changes": "Refactored blockUpdateGeneric and blockUpdateAlpha1 to use a fixed unroll factor with a computed unrolled prefix length (wU) to help the compiler eliminate bounds checks and reduce loop overhead. Added a fast return when A.C==0 and a small width\u003c=0 guard."
}