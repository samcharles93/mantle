--- a/internal/tensor/gemm.go
+++ b/internal/tensor/gemm.go
@@ -1,214 +1,250 @@
 package tensor
 
 import "runtime"
@@
 func gemmRangeRows(C, A, B *Mat, alpha, beta float32, rs, re int) {
 	// Fast path: common inference case alpha=1, beta=0.
 	if alpha == 1 && beta == 0 {
 		gemmRangeRowsAlpha1Beta0(C, A, B, rs, re)
 		return
 	}
@@
-	// m := A.R
-	// _ = m
-	n := B.C
-	k := A.C
-
-	aStride := A.Stride
-	bStride := B.Stride
-	cStride := C.Stride
-
-	// Blocked loops.
-	for i0 := rs; i0 < re; i0 += tileM {
-		iMax := min(i0+tileM, re)
-		for k0 := 0; k0 < k; k0 += tileK {
-			kMax := min(k0+tileK, k)
-			for j0 := 0; j0 < n; j0 += tileN {
-				jMax := min(j0+tileN, n)
-				blockUpdateGeneric(C.Data, A.Data, B.Data, cStride, aStride, bStride, alpha, i0, iMax, j0, jMax, k0, kMax)
-			}
-		}
-	}
+	n := B.C
+	k := A.C
+
+	aStride := A.Stride
+	bStride := B.Stride
+	cStride := C.Stride
+
+	cData := C.Data
+	aData := A.Data
+	bData := B.Data
+
+	// Blocked loops.
+	for i0 := rs; i0 < re; i0 += tileM {
+		iMax := min(i0+tileM, re)
+		for k0 := 0; k0 < k; k0 += tileK {
+			kMax := min(k0+tileK, k)
+			for j0 := 0; j0 < n; j0 += tileN {
+				jMax := min(j0+tileN, n)
+				blockUpdateGeneric(cData, aData, bData, cStride, aStride, bStride, alpha, i0, iMax, j0, jMax, k0, kMax)
+			}
+		}
+	}
 }
@@
 func gemmRangeRowsAlpha1Beta0(C, A, B *Mat, rs, re int) {
 	// beta==0: clear C range once, then accumulate.
 	cStride := C.Stride
 	n := C.C
 	cData := C.Data
@@
 	// Blocked loops.
 	for i0 := rs; i0 < re; i0 += tileM {
 		iMax := min(i0+tileM, re)
 		for k0 := 0; k0 < k; k0 += tileK {
 			kMax := min(k0+tileK, k)
 			for j0 := 0; j0 < n; j0 += tileN {
 				jMax := min(j0+tileN, n)
-				blockUpdateAlpha1(cData, aData, bData, cStride, aStride, bStride, i0, iMax, j0, jMax, k0, kMax)
+				blockUpdateAlpha1(cData, aData, bData, cStride, aStride, bStride, i0, iMax, j0, jMax, k0, kMax)
 			}
 		}
 	}
 }
 
 func blockUpdateGeneric(cData, aData, bData []float32, cStride, aStride, bStride int, alpha float32, i0, iMax, j0, jMax, k0, kMax int) {
-	width := jMax - j0
-	for i := i0; i < iMax; i++ {
-		aRow := aData[i*aStride:]
-		cOff := i*cStride + j0
-		cRow := cData[cOff : cOff+width]
-
-		for kk := k0; kk < kMax; kk++ {
-			aik := aRow[kk] * alpha
-			bOff := kk*bStride + j0
-			bRow := bData[bOff : bOff+width]
-
-			j := 0
-			for ; j+7 < width; j += 8 {
-				cRow[j+0] += aik * bRow[j+0]
-				cRow[j+1] += aik * bRow[j+1]
-				cRow[j+2] += aik * bRow[j+2]
-				cRow[j+3] += aik * bRow[j+3]
-				cRow[j+4] += aik * bRow[j+4]
-				cRow[j+5] += aik * bRow[j+5]
-				cRow[j+6] += aik * bRow[j+6]
-				cRow[j+7] += aik * bRow[j+7]
-			}
-			for ; j < width; j++ {
-				cRow[j] += aik * bRow[j]
-			}
-		}
-	}
+	width := jMax - j0
+	for i := i0; i < iMax; i++ {
+		aRow := aData[i*aStride:]
+		cOff := i*cStride + j0
+		cRow := cData[cOff : cOff+width]
+
+		for kk := k0; kk < kMax; kk++ {
+			aik := aRow[kk] * alpha
+			bOff := kk*bStride + j0
+			bRow := bData[bOff : bOff+width]
+
+			// Unroll by 16 for the common tile width (64) to reduce loop overhead.
+			j := 0
+			for ; j+15 < width; j += 16 {
+				cRow[j+0] += aik * bRow[j+0]
+				cRow[j+1] += aik * bRow[j+1]
+				cRow[j+2] += aik * bRow[j+2]
+				cRow[j+3] += aik * bRow[j+3]
+				cRow[j+4] += aik * bRow[j+4]
+				cRow[j+5] += aik * bRow[j+5]
+				cRow[j+6] += aik * bRow[j+6]
+				cRow[j+7] += aik * bRow[j+7]
+				cRow[j+8] += aik * bRow[j+8]
+				cRow[j+9] += aik * bRow[j+9]
+				cRow[j+10] += aik * bRow[j+10]
+				cRow[j+11] += aik * bRow[j+11]
+				cRow[j+12] += aik * bRow[j+12]
+				cRow[j+13] += aik * bRow[j+13]
+				cRow[j+14] += aik * bRow[j+14]
+				cRow[j+15] += aik * bRow[j+15]
+			}
+			for ; j+7 < width; j += 8 {
+				cRow[j+0] += aik * bRow[j+0]
+				cRow[j+1] += aik * bRow[j+1]
+				cRow[j+2] += aik * bRow[j+2]
+				cRow[j+3] += aik * bRow[j+3]
+				cRow[j+4] += aik * bRow[j+4]
+				cRow[j+5] += aik * bRow[j+5]
+				cRow[j+6] += aik * bRow[j+6]
+				cRow[j+7] += aik * bRow[j+7]
+			}
+			for ; j < width; j++ {
+				cRow[j] += aik * bRow[j]
+			}
+		}
+	}
 }
 
 func blockUpdateAlpha1(cData, aData, bData []float32, cStride, aStride, bStride int, i0, iMax, j0, jMax, k0, kMax int) {
-	width := jMax - j0
-	for i := i0; i < iMax; i++ {
-		aRow := aData[i*aStride:]
-		cOff := i*cStride + j0
-		cRow := cData[cOff : cOff+width]
-
-		for kk := k0; kk < kMax; kk++ {
-			aik := aRow[kk]
-			bOff := kk*bStride + j0
-			bRow := bData[bOff : bOff+width]
-
-			j := 0
-			for ; j+7 < width; j += 8 {
-				cRow[j+0] += aik * bRow[j+0]
-				cRow[j+1] += aik * bRow[j+1]
-				cRow[j+2] += aik * bRow[j+2]
-				cRow[j+3] += aik * bRow[j+3]
-				cRow[j+4] += aik * bRow[j+4]
-				cRow[j+5] += aik * bRow[j+5]
-				cRow[j+6] += aik * bRow[j+6]
-				cRow[j+7] += aik * bRow[j+7]
-			}
-			for ; j < width; j++ {
-				cRow[j] += aik * bRow[j]
-			}
-		}
-	}
+	width := jMax - j0
+	for i := i0; i < iMax; i++ {
+		aRow := aData[i*aStride:]
+		cOff := i*cStride + j0
+		cRow := cData[cOff : cOff+width]
+
+		for kk := k0; kk < kMax; kk++ {
+			aik := aRow[kk]
+			bOff := kk*bStride + j0
+			bRow := bData[bOff : bOff+width]
+
+			j := 0
+			for ; j+15 < width; j += 16 {
+				cRow[j+0] += aik * bRow[j+0]
+				cRow[j+1] += aik * bRow[j+1]
+				cRow[j+2] += aik * bRow[j+2]
+				cRow[j+3] += aik * bRow[j+3]
+				cRow[j+4] += aik * bRow[j+4]
+				cRow[j+5] += aik * bRow[j+5]
+				cRow[j+6] += aik * bRow[j+6]
+				cRow[j+7] += aik * bRow[j+7]
+				cRow[j+8] += aik * bRow[j+8]
+				cRow[j+9] += aik * bRow[j+9]
+				cRow[j+10] += aik * bRow[j+10]
+				cRow[j+11] += aik * bRow[j+11]
+				cRow[j+12] += aik * bRow[j+12]
+				cRow[j+13] += aik * bRow[j+13]
+				cRow[j+14] += aik * bRow[j+14]
+				cRow[j+15] += aik * bRow[j+15]
+			}
+			for ; j+7 < width; j += 8 {
+				cRow[j+0] += aik * bRow[j+0]
+				cRow[j+1] += aik * bRow[j+1]
+				cRow[j+2] += aik * bRow[j+2]
+				cRow[j+3] += aik * bRow[j+3]
+				cRow[j+4] += aik * bRow[j+4]
+				cRow[j+5] += aik * bRow[j+5]
+				cRow[j+6] += aik * bRow[j+6]
+				cRow[j+7] += aik * bRow[j+7]
+			}
+			for ; j < width; j++ {
+				cRow[j] += aik * bRow[j]
+			}
+		}
+	}
 }